# Create

The create subcommand creates the UQ run files.

To run the command:

`duqtools create`

Check out [the command-line interface](/command-line-interface/#create) for more info on how to use this command.


## The `create` config

The options of the create subcommand are stored in the `create` key in the config. For example:

```yaml title="duqtools.yaml"
create:
  template: template_model
  data:
    db: jet
    run_in_start_at: 7000
    run_out_start_at: 8000
  matrix:
    - ids: profiles_1d/0/zeff
      operator: add
      values: [0.01, 0.02, 0.03]
    - ids: profiles_1d/0/t_i_average
      operator: multiply
      values: [1.1, 1.2, 1.3]
    - sampling: normal
      bounds: symmetric
      ids: profiles_1d/0/q
      n_samples: 5
  sampler:
    method: latin-hypercube
    n_samples: 5
```


`template`

: The create subroutine takes as a template directory. This can be a directory with a finished run, or one just stored by JAMS (but not yet started). `duqtools` uses the input IDS machine (`db`) name, `user`, `shot`, `run` number from `jetto.in` to find the data to modify for the UQ runs.

`data`

: Next, we specify the output. The `data` key specifies the machine or imas db name where to store the data (`db`). `duqtools` will write the input data files for UQ start with the run number given by `run_in_start_at`. The data generated by the UQ runs (from jetto) will be stored starting by the run number given by `run_out_start_at`. These are generated in sequence. For the series of runs in this example, the generated input stored at run number 7000 would correspond to 8000, 7001 to 8001, 7002 to 8002, etc.

`matrix`

: The `matrix` specifies the operations to apply. These are compound operations which are expanded to fill a matrix of all possible combinations. This generates the [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product) of all operations. This means that for this example, 9 (3 for `zeff` times 3 for `t_i_average`) data files will be written for all possible combinations.

`sampler`

: For efficient UQ, it may not be necessary to sample the entire matrix or hypercube. By default, the cartesian product is taken. For more efficient sampling of the space, the following `method` choices are available: [`latin-hypercube`](https://en.wikipedia.org/wiki/Latin_hypercube_sampling), [`sobol`](https://en.wikipedia.org/wiki/Sobol_sequence), [`halton`](https://en.wikipedia.org/wiki/Halton_sequence). Where `n_samples` gives the number of samples to extract.

### IDS operations

These instructions operate on the template model. Note that these are compound operations, so they are expanded to fill the matrix with possible entries for data modifications (depending on the sampling method).

#### Arithmetic operations

This operation takes the IDS data from the specified path and applies a simple arithmetic operation to it when copying it to the new IMAS DB entry.

`ids`

: Path to the IDS data to modify. `core_profiles` is implied.

`operator`

: Which operator to apply to the data in combination with any of the given `values` below. This can be any of the basic [numpy arithmetic operations](https://numpy.org/doc/stable/reference/routines.math.html#arithmetic-operations), i.e. 'add', 'multiply', 'divide', 'power', 'subtract', 'floor_divide', 'mod', and 'remainder'.

`values`

: List of values to use.

For example:

```yaml
ids: zeff
operator: add
values: [0.01, 0.02, 0.03]
```

will generate 3 entries, `zeff += 0.01`, `zeff += 0.02`, and `zeff += 0.03`.

```yaml
ids: profiles_1d/0/t_i_average
operator: multiply
values: [1.1, 1.2, 1.3]
```

will generate another 3 entries, `t_i_average *= 1.1`, `t_i_average *= 1.2`, and `t_i_average *= 1.3`.

!!! note

    The python equivalent is essentially `np.<operator>(ids, value, out=ids)` for each of the given values.

#### Error bound sampling

This operation samples data between the given error bounds.

takes the IDS data from the specified path and applies a simple arithmetic operation to it when copying it to the new IMAS DB entry.


```yaml title="duqtools.yaml"
ids: profiles_1d/0/q
sampling: normal
bounds: symmetric
n_samples: 5
```


`ids`

: Path to the IDS data to modify. `core_profiles` is implied.

`sampling`

: Sampling method to use. Currently `normal` is the only option.

`bounds`

: Specify `symmetric` or `asymmetric` sampling. Use `auto` to choose `asymmetric` if the lower bounds are defined, else `symmetric`. The bounds are defiend by `$IDS_error_upper` and `$IDS_error_lower` in the data specification. Symmetric sampling sampling when both the lower and upper error bounds are present, takes the average of the two.

`n_samples`

: Number of samples to take.


!!! note

     Note that the example above adds 5 (`n_samples`) entries to the matrix. This is independent from the hypercube sampling above.
