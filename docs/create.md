# Create

The create subcommand creates the UQ run files.

To run the command:

`duqtools create`

## The `create` config

The options of the create subcommand are stored in the `create` key in the config. For example:


```yaml
# duqtools.yaml
create:
  template: template_model
  data:
    db: jet
    run_in_start_at: 7000
    run_out_start_at: 8000
  matrix:
    - ids: profiles_1d/0/zeff
      operator: add
      values: [0.01, 0.02, 0.03]
    - ids: profiles_1d/0/t_i_average
      operator: multiply
      values: [1.1, 1.2, 1.3]
  sampler:
    method: latin-hypercube
    n_samples: 5

```

`template`: The create subroutine takes as a template directory. This can be a directory with a finished run, or one just stored by JAMS (but not yet started). `duqtools` uses the input IDS machine (`db`) name, `user`, `shot`, `run` number from `jetto.in` to find the data to modify for the UQ runs.

`data`: Next, we specify the output. The `data` key specifies the machine or imas db name where to store the data (`db`). `duqtools` will write the input data files for UQ start with the run number given by `run_in_start_at`. The data generated by the UQ runs (from jetto) will be stored starting by the run number given by `run_out_start_at`. These are generated in sequence. For the series of runs in this example, the generated input stored at run number 7000 would correspond to 8000, 7001 to 8001, 7002 to 8002, etc.

`matrix`: The `matrix` specifies the operations to apply. These are compound operations which are expanded to fill a matrix of all possible combinations. This generates the [Cartesian product](https://en.wikipedia.org/wiki/Cartesian_product) of all operations. This means that for this example, 9 (3 for `zeff` times 3 for `t_i_average`) data files will be written for all possible combinations.

`sampler`: For efficient UQ, it may not be necessary to sample the entire matrix or hypercube. By default, the cartesian product is taken. For more efficient sampling of the space, the following options are available:

- `latin-hypercube`: [Laton hypercube](https://en.wikipedia.org/wiki/Latin_hypercube_sampling)
- `sobol`: [Sobol sequence](https://en.wikipedia.org/wiki/Sobol_sequence)
- `halton`: [Halton sequence](https://en.wikipedia.org/wiki/Halton_sequence)

Where `n_samples` gives the number of samples to extract.

### IDS operations

These instructions operate on the template model. Note that these are compound operations, so they are expanded to fill the matrix with possible entries for data modifications (depending on the sampling method).

#### Arithmetic operations

`ids`: Path to the IDS data to modify. `core_profiles` is implied.
`operator`: Which operator to apply to the data in combination with any of the given `values` below. This can be any of the basic [numpy arithmetic operations](https://numpy.org/doc/stable/reference/routines.math.html#arithmetic-operations), i.e. 'add', 'multiply', 'divide', 'power', 'subtract', 'floor_divide', 'mod', and 'remainder'.
`values`: List of values to use.

For example:

```yaml
ids: zeff
operator: add
values: [0.01, 0.02, 0.03]
```

will generate 3 entries, `zeff += 0.01`, `zeff += 0.02`, and `zeff += 0.03`.

```yaml
ids: profiles_1d/0/t_i_average
operator: multiply
values: [1.1, 1.2, 1.3]
```

will generate another 3 entries, `t_i_average *= 1.1`, `t_i_average *= 1.2`, and `t_i_average *= 1.3`.

!!! note The python equivalent is essentially `np.<operator>(ids, value, out=ids)` for each of the given values.

#### Error bound sampling

[WIP]
