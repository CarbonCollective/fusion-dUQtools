from getpass import getuser
from typing import List, Union

from pydantic import DirectoryPath, Field

from ..ids.operation import IDSOperationSet
from ..ids.sampler import IDSSamplerSet
from ._description_helpers import formatter as f
from .basemodel import BaseModel
from .data_location import DataLocation
from .samplers import CartesianProduct, HaltonSampler, LHSSampler, SobolSampler


class CreateConfig(BaseModel):
    """The options of the `create` subcommand are stored in the `create` key in
    the config."""
    matrix: List[Union[IDSOperationSet, IDSSamplerSet]] = Field(
        [IDSOperationSet(), IDSSamplerSet()],
        description=f("""
        The `matrix` specifies the operations to apply. These are compound
        operations which are expanded to fill a matrix of all possible
        combinations. This generates the
        [Cartesian product](en.wikipedia.org/wiki/Cartesian_product)
        of all operations. By specifying a different `sampler`, a subset of
        this hypercube can be efficiently sampled.
"""))

    sampler: Union[LHSSampler, HaltonSampler, SobolSampler,
                   CartesianProduct] = Field(default=LHSSampler(),
                                             discriminator='method',
                                             description=f("""
        For efficient UQ, it may not be necessary to sample the entire matrix
        or hypercube. By default, the cartesian product is taken. For more
        efficient sampling of the space, the following `method` choices are
        available:
        [`latin-hypercube`](en.wikipedia.org/wiki/Latin_hypercube_sampling),
        [`sobol`](en.wikipedia.org/wiki/Sobol_sequence),
        [`halton`](en.wikipedia.org/wiki/Halton_sequence).
        Where `n_samples` gives the number of samples to extract.
                                                """))

    template: DirectoryPath = Field(
        f'/pfs/work/{getuser()}/jetto/runs/duqtools_template',
        description=f("""
        The create subroutine takes as a template directory. This can be a
        directory with a finished run, or one just stored by JAMS (but not yet
        started). Duqtools uses the input IDS machine (db) name, user, shot,
        run number from e.g. `jetto.in` to find the data to modify for the
        UQ runs.
        """))

    data: DataLocation = Field(DataLocation(),
                               description=f("""
        Where to store the in/output IDS data.
        The data key specifies the machine or imas
        `db` name where to store the data (`db`). duqtools will write the input
        data files for UQ start with the run number given by `run_in_start_at`.
        The data generated by the UQ runs (e.g. from jetto) will be stored
        starting by the run number given by `run_out_start_at`.
        """))
