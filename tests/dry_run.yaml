plot:  # Configuration for the plotting subcommand
  plots:
  - x: profiles_1d/0/grid/rho_tor_norm  # IDS of the data to plot on the x-axis, default is rho toroidal norm.
    y: profiles_1d/0/electrons/density_thermal # IDS of the data to plot on the y-axis
    xlabel: # Custom label for x-axis
    ylabel: # Custom label for y-axis
  - x: profiles_1d/0/grid/rho_tor_norm  # IDS of the data to plot on the x-axis, default is rho toroidal norm.
    y: profiles_1d/0/t_i_average # IDS of the data to plot on the y-axis
    xlabel: Rho tor. # Custom label for x-axis
    ylabel: Ion temperature # Custom label for y-axis
create: # Configuration for the create subcommand
  matrix:  # The `matrix` specifies the operations to apply. These are compound operations which are expanded to fill a matrix of all possible combinations. This generates the [Cartesian product](en.wikipedia.org/wiki/Cartesian_product) of all operations. By specifying a different `sampler`, a subset of this hypercube can be efficiently sampled.
  - operator: multiply  # Which operator to apply to the data in combination with any of the given values below. This can be any of the basic numpy arithmetic operations. Available choices: `add`, `multiply`, `divide`, `power`, `subtract`, `floor_divide`, `mod`, and `remainder`. These directly map to the equivalent numpy functions, i.e. `add` -> `np.add`.
    ids: profiles_1d/0/t_i_average # IDS Path of the data to modify. `core_profiles` is implied.
    values: # Values to use with operator on field to create sampling space.
    - 1.1
    - 1.2
    - 1.3
  - distribution: normal  # Sample from given distribution. Currently `normal` is the only option.
    bounds: symmetric # Specify `symmetric` or `asymmetric` sampling. Use `auto` to choose `asymmetric` if the lower bounds are defined, else `symmetric`. The bounds are defiend by `$IDS_error_upper` and `$IDS_error_lower` in the data specification. Symmetric sampling sampling when both the lower and upper error bounds are present, takes the average of the two.
    ids: profiles_1d/0/t_i_average # IDS Path of the data to modify. `core_profiles` is implied.
    n_samples: 5 # Number of samples to get.
  sampler: # For efficient UQ, it may not be necessary to sample the entire matrix or hypercube. By default, the cartesian product is taken. For more efficient sampling of the space, the following `method` choices are available: [`latin-hypercube`](en.wikipedia.org/wiki/Latin_hypercube_sampling), [`sobol`](en.wikipedia.org/wiki/Sobol_sequence), [`halton`](en.wikipedia.org/wiki/Halton_sequence). Where `n_samples` gives the number of samples to extract.
    method: latin-hypercube
    n_samples: 3  # Number of samples to take
  data:
    db: 'test'
    run_in_start_at: 7010
    run_out_start_at: 8010
  template: ./template_model # The create subroutine takes as a template directory. This can be a directory with a finished run, or one just stored by JAMS (but not yet started). Duqtools uses the input IDS machine (db) name, user, shot, run number from e.g. `jetto.in` to find the data to modify for the UQ runs.
workspace:
  root: .  # The folder from which experiments have to be run, rjettov runs relative to this folder
